// Copyright EPFL contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

{ name: "dma",
  clock_primary: "clk_i",
  bus_interfaces: [
    { protocol: "reg_iface", direction: "device" }
  ],
  regwidth: "32",
  registers: [
    { name:     "PTR_IN",
      desc:     "Input data pointer (word aligned)",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        { bits: "31:0", name: "PTR_IN", desc: "Input data pointer (word aligned)" }
      ]
    },
    { name:     "PTR_OUT",
      desc:     "Output data pointer (word aligned)",
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        { bits: "31:0", name: "PTR_OUT", desc: "Output data pointer (word aligned)" }
      ]
    },
    { name:     "DMA_START",
      desc:     "Number of bytes to copy - Once a value is written, the copy starts",
      swaccess: "rw",
      hwaccess: "hro",
      hwqe:     "true", // enable `qe` latched signal of software write pulse
      fields: [
        { bits: "31:0", name: "DMA_START", desc: "DMA counter and start" }
      ]
    },
    { name:     "DONE",
      desc:     "Register set to 1 when copy is done",
      swaccess: "ro",
      hwaccess: "hwo",
      resval:   1,
      fields: [
        { bits: "0", name: "DONE", desc: "Copy done", hwaccess: "hrw"},
        { bits: "1", name: "HALFWAY", desc: "set if DMA is copying second half"},
      ]
    },
    { name:     "SRC_PTR_INC",
      desc:     "Increment number of source pointer every time a word is copied from source",
      swaccess: "rw",
      hwaccess: "hro",
      resval:   4,
      fields: [
        { bits: "31:0", name: "SRC_PTR_INC", desc: "Source pointer increment" }
      ]
    },
    { name:     "DST_PTR_INC",
      desc:     "Increment number of source pointer every time a word is copied to destination",
      swaccess: "rw",
      hwaccess: "hro",
      resval:   4,
      fields: [
        { bits: "31:0", name: "DST_PTR_INC", desc: "Destination pointer increment" }
      ]
    },
    { name:     "RX_WAIT_MODE",
      desc:     '''Special wait mode selection. 
                   To make the FIFO wait for 
                   peripherals to have valid data.''',      
      swaccess: "rw",
      hwaccess: "hro",
      resval:   0,
      fields: [
        { bits: "31:0", name: "PERIPHERAL_MASK",
          desc: "PERIPHERAL to wait for"
        }
      ]
    },
    { name:     "TX_WAIT_MODE",
      desc:     '''Special wait mode selection. 
                   To make the FIFO wait for 
                   peripherals to be ready for data.
                   mask''',
      swaccess: "rw",
      hwaccess: "hro",
      resval:   0,
      fields: [
        { bits: "31:0", name: "PERIPHERAL_MASK",
          desc: "PERIPHERAL to wait for"
        }
      ]
    }
    { name:     "DATA_TYPE",
      desc:     "Data type to transfer: 32-bit word(0), 16-bit half word(1), 8-bit byte(2,3).",
      swaccess: "rw",
      hwaccess: "hro",
      resval:   0,
      fields: [
        { bits: "1:0", name: "DATA_TYPE", 
          desc: "Data type",
          enum: [
            { value: "0", name: "DMA_32BIT_WORD", desc: "Transfers 32 bits"},
            { value: "1", name: "DMA_16BIT_WORD", desc: "Transfers 16 bits"},
            { value: "2", name: "DMA_8BIT_WORD" , desc: "Transfers  8 bits"},
            { value: "3", name: "DMA_8BIT_WORD_2",desc: "Transfers  8 bits"},
          ]
        }
      ]
    }
    { name:     "CIRCULAR_MODE",
      desc:     '''Restarts copying as soon as end of buffer is reach.
                   Will trigger DMA interrupt twice: halfway and end of buffer.
                   To end clear this flag to finish current transaction. ''',
      swaccess: "rw",
      hwaccess: "hro",
      fields: [
        { bits: "0", name: "CIRCULAR_MODE", desc: "Enables ciruclar mode" }
      ]
    },
   ]
}
